# import random\n\n# --- Music Theory Data ---\n\n# Notes (including sharps for easier interval calculation)\nnotes = [\n    'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'\n]\n\n# Intervals (semitones) for scales relative to root\n# Major: W-W-H-W-W-W-H (2, 2, 1, 2, 2, 2, 1) -> Degrees 0, 2, 4, 5, 7, 9, 11 semitones\n# Minor: W-H-W-W-H-W-W (Natural Minor) -> Degrees 0, 2, 3, 5, 7, 8, 10 semitones\nscale_intervals = {\n    'major': [0, 2, 4, 5, 7, 9, 11],\n    'minor': [0, 2, 3, 5, 7, 8, 10] # Using Natural Minor scale intervals for note positions\n}\n\n# Roman numerals for degrees (used as keys in the diatonic_chords_map)\nmajor_degrees_map = {\n    0: 'I', 1: 'ii', 2: 'iii', 3: 'IV', 4: 'V', 5: 'vi', 6: 'vii°'\n}\nminor_degrees_map = {\n    0: 'i', 1: 'ii°', 2: 'III', 3: 'iv', 4: 'V', 5: 'VI', 6: 'vii°' # Degrees in minor\n}\n\n# Chord qualities built on each degree in major and harmonic minor keys\n# Using V7 for the dominant chord (degree 4/V) in both keys for stronger resolution\n# Note: This is a simplification. Other qualities exist (e.g., maj7, min7, dim7).\nchord_qualities = {\n    'major': ['maj', 'min', 'min', 'maj', '7', 'min', 'dim'],\n    'minor': ['min', 'dim', 'maj', 'min', '7', 'maj', 'dim'] # Harmonic minor qualities on natural minor roots\n}\n\n# Basic transition rules: maps current degree to a list of possible next degrees\n# These are common, strong movements in tonal harmony. More complex rules exist.\ntransition_rules = {\n    'major': {\n        'I': ['IV', 'V', 'vi', 'ii'], # Tonic can go to IV, V, vi, or ii\n        'ii': ['V'], # ii typically leads to V\n        'iii': ['vi', 'IV'], # iii often leads to vi or IV\n        'IV': ['V', 'ii', 'I'], # IV often leads to V or ii, sometimes back to I\n        'V': ['I', 'vi'], # V typically resolves to I (authentic cadence) or vi (deceptive cadence)\n        'vi': ['ii', 'IV', 'V'], # vi often leads to ii, IV, or V\n        'vii°': ['I'] # vii° strongly resolves to I\n    },\n     'minor': {\n        'i': ['iv', 'V', 'VI', 'ii°'],\n        'ii°': ['V'],\n        'III': ['VI', 'iv'],\n        'iv': ['V', 'ii°', 'i'],\n        'V': ['i', 'VI'],\n        'VI': ['ii°', 'iv', 'V'],\n        'vii°': ['i']\n    }\n}\n\n\n# --- Helper Functions ---\n\ndef parse_chord(chord_name):\n    \"\"\"Parses a chord name string into root and quality.\"\"\"\n    # Basic parsing: Assumes root is first char(s), quality is suffix.\n    # Handles sharps/flats at the second character position.\n    root = chord_name[0]\n    quality = ''\n    if len(chord_name) > 1 and chord_name[1] in ['#', 'b']:\n         root += chord_name[1]\n         quality = chord_name[2:]\n    else:\n        quality = chord_name[1:]\n\n    # Return root and quality string (e.g., \"C\", \"maj\")\n    return root, quality\n\ndef get_diatonic_chords(root, key_type):\n    \"\"\"\n    Generates a dictionary mapping degree (Roman numeral) to chord name\n    for a given key root and type (major/minor).\n    Uses harmonic minor qualities on natural minor scale roots for minor keys.\n    \"\"\"\n    if key_type not in scale_intervals:\n        raise ValueError(f\"Invalid key type: {key_type}. Choose 'major' or 'minor'.\")\n\n    try:\n        root_index = notes.index(root)\n    except ValueError:\n        raise ValueError(f\"Invalid root note: {root}\")\n\n    # Get the notes of the scale (using natural minor notes for roots in minor keys)\n    scale_to_use_intervals = scale_intervals[key_type] # Use major or natural minor intervals\n    diatonic_scale_notes = []\n    for interval in scale_to_use_intervals:\n        diatonic_scale_notes.append(notes[(root_index + interval) % 12])\n\n    diatonic_chords_map = {}\n    degree_map = major_degrees_map if key_type == 'major' else minor_degrees_map\n    qualities = chord_qualities[key_type] # Use major or harmonic minor qualities\n\n    for i in range(7):\n        degree_numeral = degree_map[i]\n        chord_root = diatonic_scale_notes[i]\n        chord_quality_suffix = qualities[i]\n        chord_name = chord_root + chord_quality_suffix\n        diatonic_chords_map[degree_numeral] = chord_name\n\n    return diatonic_chords_map\n\ndef get_degree(chord_name, key_chords_map):\n    \"\"\"Finds the Roman numeral degree for a given chord name within a key.\"\"\"\n    # Find the degree based on the chord name matching a diatonic chord.\n    for degree, name in key_chords_map.items():\n        if name == chord_name:\n            return degree\n    # If the chord isn't found, it's not diatonic in the key based on our definition.\n    return None # Return None if not found\n\ndef get_chord_from_degree(degree, key_chords_map):\n    \"\"\"Finds the chord name for a given Roman numeral degree within a key.\"\"\"\n    if degree in key_chords_map:\n        return key_chords_map[degree]\n    # This case should ideally not happen if rules are well-defined\n    raise ValueError(f\"Degree '{degree}' not found in the diatonic chords map for this key.\")\n\n\n# --- Main Function ---\n\ndef generate_progression(start_chord, length=4):\n    \"\"\"\n    Generates a chord progression based on basic tonal harmony rules.\n\n    Infers the key based on the starting chord's root and a simplified\n    quality check ('maj' -> major key, 'min'/'dim' -> minor key, '7' -> V7\n    guessing key tonic is a fifth below).\n\n    Args:\n        start_chord (str): The starting chord (e.g., \"Cmaj\", \"Amin\", \"G7\").\n                           Must be a diatonic chord in the inferred key.\n        length (int): The desired number of chords in the progression.\n\n    Returns:\n        list: A list of chord names forming the progression.\n              Returns a string error message if generation fails.\n    \"\"\"\n    if length < 1:\n        return [] if length == 0 else \"Error: Length must be a non-negative integer.\"\n    if length == 1:\n        return [start_chord]\n\n    try:\n        # 1. Attempt to determine key and type from start chord (Heuristic)\n        start_root, start_quality = parse_chord(start_chord)\n\n        key_root = None\n        key_type = None\n        inferred_key_from_V7 = False # Flag if inference assumed V7\n\n        if start_quality == 'maj':\n             # Guess: start chord is I in a Major key\n             key_root = start_root\n             key_type = 'major'\n        elif start_quality == 'min' or start_quality == 'dim':\n             # Guess: start chord is i or ii° in a Minor key (assume i for key root)\n             key_root = start_root\n             key_type = 'minor'\n        elif start_quality == '7':\n            # Guess: start chord is V7 in some key. The key root is a perfect fifth down.\n            try:\n                start_root_index = notes.index(start_root)\n                # Perfect fifth down is 7 semitones down (or 5 semitones up)\n                key_root_index = (start_root_index - 7 + 12) % 12\n                key_root = notes[key_root_index]\n                # V7 is most commonly V in a Major key, but also V in harmonic minor.\n                # We will try both major and minor later if needed. Start with major guess.\n                key_type = 'major'\n                inferred_key_from_V7 = True\n            except ValueError:\n                 raise ValueError(f\"Could not parse root note '{start_root}' from starting chord.\")\n        else:\n             # Fallback or error for unknown quality\n             raise ValueError(f\"Cannot reliably determine key type from starting chord quality '{start_quality}'. Use qualities like 'maj', 'min', 'dim', or '7'.\")\n\n        # 2. Get diatonic chords for the inferred key and verify the start chord\n        current_degree = None\n        possible_keys_to_try = []\n\n        if inferred_key_from_V7:\n             # If inferred from V7, the key root is fixed, but type could be major or minor\n             possible_keys_to_try = [(key_root, 'major'), (key_root, 'minor')]\n        else:\n             # If inferred from Tonic (I/i), the root is fixed, type was guessed\n             # Try the guessed type first, then the other type for the same root\n             opposite_type = 'minor' if key_type == 'major' else 'major'\n             possible_keys_to_try = [(key_root, key_type), (key_root, opposite_type)]\n\n\n        determined_key_root = None\n        determined_key_type = None\n        key_chords_map = None\n\n        for root_guess, type_guess in possible_keys_to_try:\n             try:\n                 # Generate chords for this potential key\n                 temp_key_chords_map = get_diatonic_chords(root_guess, type_guess)\n                 # Check if the starting chord exists in this key's diatonic chords\n                 temp_degree = get_degree(start_chord, temp_key_chords_map)\n                 if temp_degree is not None:\n                     # Found the key and the degree! Use this key.\n                     determined_key_root = root_guess\n                     determined_key_type = type_guess\n                     key_chords_map = temp_key_chords_map\n                     current_degree = temp_degree\n                     break # Exit the loop once a valid key is found\n             except ValueError:\n                 # This specific key combination might be invalid (e.g., invalid root note)\n                 # Just skip to the next possibility\n                 pass\n\n\n        if current_degree is None:\n            # If after trying all plausible key guesses, the start chord isn't diatonic\n            raise ValueError(f\"Starting chord '{start_chord}' is not a standard diatonic chord in any commonly inferred key based on its root and quality.\")\n\n\n        # Use the successfully determined key's rules\n        if determined_key_type not in transition_rules:\n             # This is a safeguard, should not happen with defined major/minor\n             raise ValueError(f\"Transition rules not defined for determined key type: {determined_key_type}\")\n        rules = transition_rules[determined_key_type]\n\n        # print(f\"Debug: Inferred Key: {determined_key_root} {determined_key_type}. Start chord {start_chord} is degree {current_degree}.\")\n        # print(f\"Debug: Diatonic Chords: {key_chords_map}\")\n\n\n        # 3. Build the progression\n        progression = [start_chord]\n\n        for _ in range(length - 1):\n            # Get possible next degrees based on rules for the current degree\n            possible_next_degrees = rules.get(current_degree, [])\n\n            if not possible_next_degrees:\n                 # Fallback: If no rule, maybe go to the tonic or dominant?\n                 # Or just stop. Let's try going to the tonic (I/i).\n                 # print(f\"Warning: No defined transitions for degree {current_degree} in {determined_key_type} key. Defaulting to Tonic (I/i).\")\n                 next_degree = 'I' if determined_key_type == 'major' else 'i'\n            else:\n                # Choose a random next degree from the possibilities\n                next_degree = random.choice(possible_next_degrees)\n\n\n            # Get the actual chord name from the next degree\n            try:\n                next_chord = get_chord_from_degree(next_degree, key_chords_map)\n            except ValueError:\n                 # This indicates an issue with the rules mapping to non-existent degrees\n                 # Should not happen with current setup, but good for robustness.\n                 print(f\"Error: Rule led to non-existent degree '{next_degree}' in key. Stopping.\")\n                 break\n\n            # Add the next chord to the progression\n            progression.append(next_chord)\n\n            # Update the current degree for the next iteration\n            current_degree = next_degree\n\n        return progression\n\n    except ValueError as e:\n        return str(e) # Return error message if something goes wrong (e.g., invalid root, chord not found)\n    except Exception as e:\n        # Catch any other unexpected errors\n        return f\"An unexpected error occurred: {e}\"\n\n\n# --- Example Usage (This part will be executed by the tool) ---\nprint(\"--- Generating progressions ---\")\n\n# Example 1: C Major, length 4 (starting on Cmaj, I chord)\nprint(\"\\nProgression 1 (C Major, length 4, starting on Cmaj):\")\nprint(generate_progression(\"Cmaj\", 4))\n\n# Example 2: C Major, length 8 (starting on Cmaj, I chord)\nprint(\"\\nProgression 2 (C Major, length 8, starting on Cmaj):\")\nprint(generate_progression(\"Cmaj\", 8))\n\n# Example 3: A Minor, length 5 (starting on Amin, i chord)\nprint(\"\\nProgression 3 (A Minor, length 5, starting on Amin):\")\nprint(generate_progression(\"Amin\", 5))\n\n# Example 4: G Major, length 6 (starting on Gmaj, I chord)\nprint(\"\\nProgression 4 (G Major, length 6, starting on Gmaj):\")\nprint(generate_progression(\"Gmaj\", 6))\n\n# Example 5: D Minor, length 4 (starting on Dmin, i chord)\nprint(\"\\nProgression 5 (D Minor, length 4, starting on Dmin):\")\nprint(generate_progression(\"Dmin\", 4))\n\n# Example 6: F Major, length 7 (starting on Fmaj, I chord)\nprint(\"\\nProgression 6 (F Major, length 7, starting on Fmaj):\")\nprint(generate_progression(\"Fmaj\", 7))\n\n# Example 7: Starting on a diatonic chord that isn't the Tonic (IV in C major - Fmaj)\nprint(\"\\nProgression 7 (Start on IV in C major - Fmaj):\")\nprint(generate_progression(\"Fmaj\", 5))\n\n# Example 8: Starting on the dominant V7 in C major (G7)\nprint(\"\\nProgression 8 (Start on V7 in C major - G7):\")\nprint(generate_progression(\"G7\", 5))\n\n# Example 9: Starting on the dominant V7 in A minor (E7)\nprint(\"\\nProgression 9 (Start on V7 in A minor - E7):\")\nprint(generate_progression(\"E7\", 5))\n\n# Example 10: Starting on a diatonic chord that isn't Tonic or Dominant (ii in C major - Dmin)\nprint(\"\\nProgression 10 (Start on ii in C major - Dmin):\")\nprint(generate_progression(\"Dmin\", 6))\n\n# Example 11: Starting on a chord with a non-standard quality not handled by inference (should raise error)\nprint(\"\\nProgression 11 (Invalid start chord - Cmaj7):\")\nprint(generate_progression(\"Cmaj7\", 4))\n\n# Example 12: Starting on a chord not diatonic in the inferred key (e.g., C#maj)\nprint(\"\\nProgression 12 (Invalid start chord - C#maj):\")\nprint(generate_progression(\"C#maj\", 4)) # Should infer C# major key, C#maj is I in C# major. This is now valid. Let's pick something else.\nprint(\"\\nProgression 12 (Invalid start chord - D#maj):\") # D#maj is not diatonic in C major or A minor.\nprint(generate_progression(\"D#maj\", 4))\n\n\n# Example 13: Length 1\nprint(\"\\nProgression 13 (C Major, length 1):\")\nprint(generate_progression(\"Cmaj\", 1))\n\n# Example 14: Length 0\nprint(\"\\nProgression 14 (C Major, length 0):\")\nprint(generate_progression(\"Cmaj\", 0))\n\n# Example 15: Negative Length\nprint(\"\\nProgression 15 (C Major, negative length):\")\nprint(generate_progression(\"Cmaj\", -2))\n\n